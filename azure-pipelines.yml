trigger:
  branches:
    include:
      - main  # Adjust to the branch you want in your GitHub repo

variables:
  azureContainerRegistry: 'letestregistry.azurecr.io'  # ACR name with domain
  imageName: 'node-app'  # Docker image name
  kubernetesCluster: 'new-aks-cluster'  # AKS Cluster name
  kubernetesNamespace: 'default'  # Kubernetes namespace
  resourceGroup: 'newton-resources'  # Azure Resource Group
  terraformDirectory: 'terraform/'  # Directory for Terraform scripts
  AZURE_SUBSCRIPTION_CONNECTION: 'd49e6059-7e63-4b1d-b093-492b8a94c5cb'  # Azure Service Connection for Azure resources
  dockerRegistryConnection: 'letestregistry'  # ACR service connection name
  githubRepo: 'https://github.com/DnT-Nutan/Terraform_Pipeline.git'  # GitHub repository URL

stages:
- stage: ProvisionInfrastructure
  jobs:
  - job: Provision
    displayName: 'Provision Azure Infrastructure with Terraform'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    # Install Terraform
    - script: |
        curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add - && \
        sudo apt-add-repository "deb https://apt.releases.hashicorp.com $(lsb_release -cs) main" && \
        sudo apt-get update && sudo apt-get install terraform
      displayName: 'Install Terraform'

    - script: |
        echo "Initializing Terraform..."
        cd $(terraformDirectory) && terraform init  
      displayName: 'Initialize Terraform'

    - script: |
        echo "Terraform plan..."
        cd $(terraformDirectory) && terraform plan 
      displayName: 'Terraform Plan'

    - script: |
        echo "Applying Terraform configurations..."
        cd $(terraformDirectory) && terraform apply -auto-approve 
      displayName: 'Apply Terraform'

- stage: BuildAndPushDockerImage
  dependsOn: ProvisionInfrastructure
  jobs:
  - job: BuildAndPush
    displayName: 'Build and Push Docker Image to ACR'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    # GitHub Checkout to pull code from the repository
    - task: Checkout@1  # Using Checkout@1 instead of Checkout@2
      displayName: 'Checkout GitHub Repo'


    # Build Docker image and push it to Azure Container Registry
    - task: Docker@2
      displayName: 'Build Docker Image'
      inputs:
        command: 'build'
        containerRegistry: 'az-pipeline-connec'  # Ensure this is the correct service connection name for your ACR
        repository: '$(azureContainerRegistry)/$(imageName)'  # Repository format: <ACR_Name>/<Image_Name>
        dockerfile: '$(Build.SourcesDirectory)/Dockerfile'  # Path to Dockerfile
        tags: '$(Build.BuildId)'  # Tag the image with Build ID for uniqueness

    - task: Docker@2
      displayName: 'Push Docker Image to ACR'
      inputs:
        command: 'push'
        containerRegistry: 'az-pipeline-connec'  # Ensure this is the correct service connection name for your ACR
        repository: '$(azureContainerRegistry)/$(imageName)'  # Repository format: <ACR_Name>/<Image_Name>
        tags: '$(Build.BuildId)'  # Push image with the Build ID tag

- stage: DeployToAKS
  dependsOn: BuildAndPushDockerImage
  jobs:
  - job: Deploy
    displayName: 'Deploy to AKS Cluster'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    # Azure CLI task for logging in to Azure
    - task: AzureCLI@2
      displayName: "Azure Login"
      inputs:
        azureSubscription: 'Azure-Cloud-Account-DNT'  # Ensure this is the correct Azure service connection reference
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Setting up kubectl to access AKS..."
          az aks get-credentials --resource-group $(resourceGroup) --name $(kubernetesCluster)
          kubectl apply -f $(Build.SourcesDirectory)/deploy.yaml
          kubectl apply -f $(Build.SourcesDirectory)/service.yaml
